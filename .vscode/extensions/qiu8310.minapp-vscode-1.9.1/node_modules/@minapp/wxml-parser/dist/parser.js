"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var structs_1 = require("./structs");
var config_1 = require("./config");
var debug = require('debug')('minapp:wxml-parser');
var ParserError = (function (_super) {
    tslib_1.__extends(ParserError, _super);
    function ParserError(index, message) {
        var _this = _super.call(this, message) || this;
        _this.index = index;
        return _this;
    }
    return ParserError;
}(Error));
exports.ParserError = ParserError;
function parse(xml) {
    var lastLocation = 0;
    var location = 0;
    return document();
    function document() {
        var doc = new structs_1.Document(xml);
        whitespace();
        var n;
        while (!eos() && (n = node())) {
            doc.nodes.push(n);
        }
        return doc;
    }
    function node() {
        var n;
        if (is('<!--')) {
            n = comment();
        }
        else {
            var m = match(/^<([\w-:.]+)\s*/);
            if (m) {
                n = tag(m[1]);
            }
            else {
                n = text();
                if (n.start === n.end) {
                    throw new ParserError(n.start, "unexpect character");
                }
            }
        }
        whitespace();
        return n;
    }
    function text() {
        var start = location;
        return new structs_1.TextNode(getTextContent().trim(), start, location);
    }
    function getTextContent() {
        var m = match(/^([\s\S]*?)(?=\{\{|<!--|<\/?([\w-:.]+)\s*)/);
        var content;
        if (!m) {
            content = xml;
            match(content);
        }
        else {
            content = m[1];
            if (is('{{')) {
                m = match(/^\{\{(.*?\}\})/);
                if (m) {
                    content += m[0];
                }
                content += getTextContent();
            }
            else {
            }
        }
        return content;
    }
    function comment() {
        debug('comment %j', xml);
        var m = match(/^<!--([\s\S]*?)-->/);
        if (!m) {
            throw new ParserError(location, "comment node has no end tag");
        }
        else {
            return new structs_1.CommentNode(m[1].trim(), lastLocation, location);
        }
    }
    function tag(name) {
        debug('tag %j', "<" + name + " " + xml);
        var n = new structs_1.TagNode(name, lastLocation);
        whitespace();
        while (!(eos() || is('>') || is('/>'))) {
            n.attrs.push(attr());
            whitespace();
        }
        if (match(/^\/>/)) {
            n.selfClose = true;
            n.end = location;
            return n;
        }
        else if (!match(/^>/)) {
            throw new ParserError(location, "expect \">\", but got nothing");
        }
        n.contentStart = location;
        if (config_1.SourceTags.indexOf(n.name) >= 0) {
            var source = match(new RegExp("([\\s\\S]*?)(<\\/" + n.name + ">)"));
            if (source) {
                n.contentEnd = location - source[2].length;
                n.end = location;
                n.children = [new structs_1.TextNode(source[1], n.contentStart, n.contentEnd)];
                return n;
            }
            else {
                throw new ParserError(location, "expect \"</" + n.name + ">\", but got nothing");
            }
        }
        whitespace();
        var closeTag = /^<\/([\w-:.]+)>/;
        var child;
        while (!eos() && !is(closeTag) && (child = node())) {
            n.children.push(child);
        }
        var m = match(closeTag);
        if (m) {
            if (m[1] === n.name) {
                n.contentEnd = lastLocation;
                n.end = location;
                return n;
            }
            else {
                throw new ParserError(lastLocation, "expect end tag \"</" + n.name + ">\", bug got \"</" + m[1] + ">\"");
            }
        }
        throw new ParserError(location, "expect end tag \"</" + n.name + ">\", bug got nothing");
    }
    function attr() {
        debug('attr %j', xml);
        var m = match(/^([\w-:.]+)\s*(=\s*("[^"]*"|'[^']*'|\w+))?/);
        if (!m)
            throw new ParserError(location, "node attribute syntax error");
        var name = m[1], hasValue = m[2], value = m[3];
        var quote = '';
        if (value) {
            quote = value[0];
            if (quote !== '"' && quote !== '\'')
                quote = '';
            else
                value = value.substr(1, value.length - 2);
        }
        return new structs_1.TagNodeAttr(name, hasValue ? value : true, quote, location, lastLocation);
    }
    function whitespace() {
        match(/^\s*/);
    }
    function match(regOrContent) {
        if (typeof regOrContent === 'string') {
            if (xml.indexOf(regOrContent) !== 0)
                return;
            lastLocation = location;
            location += regOrContent.length;
            xml = xml.slice(regOrContent.length);
            return regOrContent;
        }
        else {
            var m = xml.match(regOrContent);
            if (!m)
                return;
            lastLocation = location;
            location += m[0].length;
            xml = xml.slice(m[0].length);
            return m;
        }
    }
    function eos() {
        return 0 === xml.length;
    }
    function is(prefix) {
        if (typeof prefix === 'string') {
            return 0 === xml.indexOf(prefix);
        }
        else {
            var m = xml.match(prefix);
            return m ? m.index === 0 : false;
        }
    }
}
exports.parse = parse;
