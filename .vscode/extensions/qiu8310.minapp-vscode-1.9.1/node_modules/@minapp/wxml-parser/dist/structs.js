"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var config_1 = require("./config");
var DefaultToXMLOptions = {
    source: '',
    prefix: '',
    preferSpaces: true,
    tabSize: 2,
    eol: '\n',
    maxLineCharacters: 100,
    removeComment: false,
    reserveTags: []
};
var Document = (function () {
    function Document(source) {
        this.source = source;
        this.nodes = [];
    }
    Document.prototype.toXML = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _ = tslib_1.__assign({}, DefaultToXMLOptions, opts, { source: this.source });
        var step = (_.preferSpaces ? ' ' : '\t').repeat(_.tabSize);
        var nodes = opts.removeComment ? this.nodes.filter(removeComentNode) : this.nodes;
        return nodes.map(function (n) { return toXML(n, _.prefix, step, _); }).join(_.eol);
    };
    return Document;
}());
exports.Document = Document;
function removeComentNode(n) {
    if (n.is(TYPE.COMMENT))
        return false;
    if (n.is(TYPE.TAG))
        n.children = n.children.filter(removeComentNode);
    return true;
}
var TYPE;
(function (TYPE) {
    TYPE[TYPE["TAG"] = 0] = "TAG";
    TYPE[TYPE["TEXT"] = 1] = "TEXT";
    TYPE[TYPE["COMMENT"] = 2] = "COMMENT";
})(TYPE = exports.TYPE || (exports.TYPE = {}));
var Location = (function () {
    function Location(start, end) {
        if (start != null)
            this.start = start;
        if (end != null)
            this.end = end;
    }
    return Location;
}());
exports.Location = Location;
var Node = (function (_super) {
    tslib_1.__extends(Node, _super);
    function Node() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Node.prototype.is = function (type) {
        return type === TYPE.TAG ? this instanceof TagNode
            : type === TYPE.TEXT ? this instanceof TextNode
                : type === TYPE.COMMENT ? this instanceof CommentNode
                    : false;
    };
    Node.TYPE = TYPE;
    return Node;
}(Location));
exports.Node = Node;
var CommentNode = (function (_super) {
    tslib_1.__extends(CommentNode, _super);
    function CommentNode(comment, start, end) {
        var _this = _super.call(this, start, end) || this;
        _this.comment = comment;
        return _this;
    }
    return CommentNode;
}(Node));
exports.CommentNode = CommentNode;
var TextNode = (function (_super) {
    tslib_1.__extends(TextNode, _super);
    function TextNode(content, start, end) {
        var _this = _super.call(this, start, end) || this;
        _this.content = content;
        return _this;
    }
    return TextNode;
}(Node));
exports.TextNode = TextNode;
var TagNode = (function (_super) {
    tslib_1.__extends(TagNode, _super);
    function TagNode(name, start, end) {
        var _this = _super.call(this, start, end) || this;
        _this.name = name;
        _this.attrs = [];
        _this.children = [];
        return _this;
    }
    TagNode.prototype.getAttr = function (key) {
        return this.attrs.find(function (a) { return a.name === key; });
    };
    return TagNode;
}(Node));
exports.TagNode = TagNode;
var TagNodeAttr = (function (_super) {
    tslib_1.__extends(TagNodeAttr, _super);
    function TagNodeAttr(name, value, quote, start, end) {
        var _this = _super.call(this, start, end) || this;
        _this.name = name;
        _this.value = value;
        _this.quote = quote;
        return _this;
    }
    TagNodeAttr.prototype.toXML = function () {
        var _a = this, value = _a.value, name = _a.name, quote = _a.quote;
        return value !== true
            ? name + "=" + quote + value + quote
            : "" + name;
    };
    return TagNodeAttr;
}(Location));
exports.TagNodeAttr = TagNodeAttr;
function toXML(n, prefix, step, opts) {
    if (n.is(TYPE.COMMENT)) {
        return prefix + ("<!-- " + n.comment + " -->");
    }
    else if (n.is(TYPE.TEXT)) {
        return prefix + n.content;
    }
    else if (n.is(TYPE.TAG)) {
        var prefixedStart = prefix + "<" + n.name + n.attrs.map(function (a) { return ' ' + a.toXML(); }).join('');
        if (n.selfClose)
            return prefixedStart + ' />';
        prefixedStart += '>';
        var endTag = "</" + n.name + ">";
        if (opts.reserveTags.indexOf(n.name) >= 0 && n.contentEnd && n.contentStart) {
            return prefixedStart + opts.source.substring(n.contentStart, n.contentEnd) + endTag;
        }
        var child = n.children[0];
        if (!child)
            return prefixedStart + endTag;
        if (n.children.length === 1 && child.is(TYPE.TEXT)) {
            var str = prefixedStart + child.content + endTag;
            if (config_1.SourceTags.indexOf(n.name) >= 0 ||
                opts.maxLineCharacters === 0 ||
                str.length <= opts.maxLineCharacters)
                return str;
        }
        return [
            prefixedStart
        ].concat(n.children.map(function (_) { return toXML(_, prefix + step, step, opts); }), [
            prefix + endTag
        ]).join(opts.eol);
    }
    else {
        return '';
    }
}
