"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var onview_1 = require("./onview");
var once_1 = require("../util/once");
var viewport = {
    width: 0,
    height: 0,
    /** 监听 element 能否在当前窗口下可见 */
    listen: function (element, callback, options) {
        if (options === void 0) { options = {}; }
        var enableIntersectionObserver = options.enableIntersectionObserver, container = options.container, _a = options.offset, offset = _a === void 0 ? 0 : _a, _b = options.debounce, debounce = _b === void 0 ? 0 : _b, _c = options.throttle, throttle = _c === void 0 ? 200 : _c;
        // 默认不开始（对于那种频繁显示隐藏的元素时，没有 scroll 稳定）
        if (enableIntersectionObserver && typeof IntersectionObserver !== 'undefined') {
            // https://developers.google.com/web/updates/2016/04/intersectionobserver
            var io_1 = new IntersectionObserver(function (entries) { return entries[0].intersectionRatio > 0 && callback(entries); }, { root: container, rootMargin: offset + 'px' });
            io_1.observe(element);
            // onview 一定会在 domReady 后执行，所以 IntersectionObserver 也需要做下初始化判断
            if (viewport.visiable(element, { container: container, offset: offset }))
                callback({ type: 'init' });
            return once_1.once(function () {
                io_1.disconnect();
            });
        }
        else {
            // onview 已经包装了 once
            return onview_1.onview(function (e) {
                if (viewport.visiable(element, { container: container, offset: offset }))
                    callback(e);
            }, { throttle: throttle, debounce: debounce, container: container });
        }
    },
    /**
     * 判断元素 element 是否是在指定的 viewport 内，
     * 如果没指定 viewport，默认使用当前屏幕的宽高所在的 viewport
     */
    visiable: function (element, options) {
        if (options === void 0) { options = {}; }
        var rect = element.getBoundingClientRect();
        var container = options.container, offset = options.offset, winViewport = options.viewport;
        winViewport = expendViewport(winViewport || getDefaultViewport(), offset);
        if (container) {
            var containerRect = container.getBoundingClientRect();
            if (contains(winViewport, containerRect)) {
                var _a = expendViewport(containerRect, offset), top_1 = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
                var containerViewport = {
                    top: top_1 > winViewport.top ? top_1 : winViewport.top,
                    left: left > winViewport.left ? left : winViewport.left,
                    right: right < winViewport.right ? right : winViewport.right,
                    bottom: bottom < winViewport.bottom ? bottom : winViewport.bottom
                };
                return contains(containerViewport, rect);
            }
            else {
                return false;
            }
        }
        else {
            return contains(winViewport, rect);
        }
    },
    getViewport: getViewport
};
exports.viewport = viewport;
function getViewport() {
    return {
        width: window.innerWidth || document.documentElement.clientWidth,
        height: window.innerHeight || document.documentElement.clientHeight
    };
}
// 实时更新 viewport 的宽高
function setViewport() {
    var v = getViewport();
    viewport.width = v.width;
    viewport.height = v.height;
}
setViewport();
window.addEventListener('resize', setViewport);
function contains(parent, child) {
    return child.right >= parent.left &&
        child.bottom >= parent.top &&
        child.left <= parent.right &&
        child.top <= parent.bottom;
}
function getDefaultViewport() {
    // viewport 会变化，所以需要写在函数中，每次返回一个新对象
    return {
        top: 0,
        left: 0,
        right: viewport.width,
        bottom: viewport.height
    };
}
function expendViewport(rect, offset) {
    if (!offset)
        return rect;
    var offsetRect = typeof offset === 'number' ? { left: offset, top: offset, bottom: offset, right: offset } : offset;
    var _a = offsetRect.top, top = _a === void 0 ? 0 : _a, _b = offsetRect.left, left = _b === void 0 ? 0 : _b, _c = offsetRect.right, right = _c === void 0 ? 0 : _c, _d = offsetRect.bottom, bottom = _d === void 0 ? 0 : _d;
    return {
        top: rect.top - top,
        left: rect.left - left,
        right: rect.right + right,
        bottom: rect.bottom + bottom
    };
}
