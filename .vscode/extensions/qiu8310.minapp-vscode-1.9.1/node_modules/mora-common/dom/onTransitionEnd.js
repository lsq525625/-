"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var style_1 = require("./style");
var TRANSITION = 'transition';
var ANIMATION = 'animation';
function onTransitionEnd(el, callback, expectAnimType) {
    var _a = getTransitionInfo(el, expectAnimType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
    if (!type)
        return callback();
    var event = type === TRANSITION ? style_1.transitionEndEvent : style_1.animationEndEvent;
    var ended = 0;
    var end = function () {
        el.removeEventListener(event, onEnd);
        callback();
    };
    var onEnd = function (e) {
        if (e.target === el) {
            if (++ended >= propCount)
                end();
        }
    };
    setTimeout(function () {
        if (ended < propCount)
            end();
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
exports.onTransitionEnd = onTransitionEnd;
function getTransitionInfo(el, expectAnimType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[style_1.transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[style_1.transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[style_1.animationProp + 'Delay'].split(', ');
    var animationDurations = styles[style_1.animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    if (expectAnimType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = expectAnimType;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectAnimType === ANIMATION) {
        if (animationTimeout > 0) {
            type = expectAnimType;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0
            ? transitionTimeout > animationTimeout
                ? TRANSITION
                : ANIMATION
            : undefined;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    return { type: type, timeout: timeout, propCount: propCount };
}
exports.getTransitionInfo = getTransitionInfo;
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i]);
    }));
}
function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
}
