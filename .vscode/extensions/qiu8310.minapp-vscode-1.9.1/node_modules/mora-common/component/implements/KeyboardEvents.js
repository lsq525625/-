"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var applyMixins_1 = require("../../util/applyMixins");
var KeyCode_1 = require("../../dom/KeyCode");
var FKeyMap = reverse(KeyCode_1.FunctionKeyCode);
var PKeyMap = reverse(KeyCode_1.PrintKeyCode);
var base = {
    componentDidMount: function () {
        var _this = this;
        var handle = function (e) {
            var keySep = /\s*,\s*/;
            var segSep = /\s*\+\s*/;
            filter(Object.keys(_this.keyboard).reduce(function (map, key) {
                key.split(keySep).map(function (k) {
                    var ks = k.toLowerCase().split(segSep);
                    var printChar = ks.pop();
                    ks.sort().push(printChar); // 将 shift, ctrl, meta, alt 安字母顺序排序
                    map[ks.join('+')] = _this.keyboard[key];
                });
                return map;
            }, {}), e);
        };
        document.addEventListener('keydown', handle);
        document.addEventListener('keypress', handle);
        this.__keyboardEventOff = function () {
            document.removeEventListener('keydown', handle);
            document.removeEventListener('keypress', handle);
        };
    },
    componentWillUnmount: function () {
        this.__keyboardEventOff();
    }
};
var KeyboardEvents = /** @class */ (function (_super) {
    tslib_1.__extends(KeyboardEvents, _super);
    function KeyboardEvents() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * 在继承类上写
     *
     * ```
     * keyboard = {
     *   'ctrl+t': (e: KeyboardEvent) => void
     * }
     * ```
     */
    KeyboardEvents.apply = function () {
        return function (Ctor) { return applyMixins_1.applyMixins(Ctor, [KeyboardEvents, base], { merges: ['componentDidMount', 'componentWillUnmount'] }); };
    };
    return KeyboardEvents;
}(React.PureComponent));
exports.KeyboardEvents = KeyboardEvents;
/*
 *  每次按键，一般都会有keydown,keypress全过来，用这个函数来过滤，看用户按下的到底是什么按键
 *  keydown/keyup 是两个低层的事件，而 keypress 则属于用户层吧，一般只有在用户按下的键可以打印出来才会触发这个keypress
 */
function filter(map, e) {
    var modifiers = ''; // 表示 Alt,Ctrl,Meta,Shift这些前缀
    var keyname = null; // 键盘上显示的名字
    if (e.type === 'keydown') {
        var code = e.keyCode;
        //  Alt, Ctrl, Shift, Cmd 按下则忽略
        if ([KeyCode_1.KeyCode.shift, KeyCode_1.KeyCode.ctrl, KeyCode_1.KeyCode.alt, KeyCode_1.KeyCode.lmeta, KeyCode_1.KeyCode.rmeta].indexOf(code) >= 0)
            return;
        keyname = FKeyMap[code];
        // 按下的不是功能键，如果 Alt/Ctrl/Meta 按下了则就把这个键当作打印键
        if (!keyname && (e.altKey || e.ctrlKey || e.metaKey)) {
            keyname = PKeyMap[code];
        }
        if (keyname) {
            // 按字母顺序排列
            if (e.altKey)
                modifiers += 'alt+';
            if (e.ctrlKey)
                modifiers += 'ctrl+';
            if (e.metaKey)
                modifiers += 'meta+';
            if (e.shiftKey)
                modifiers += 'shift+';
        }
        else {
            return;
        }
    }
    else if (e.type === 'keypress') {
        // keydown 的时候已经处理了这两个键
        if (e.altKey || e.ctrlKey || e.metaKey)
            return;
        // 在Firefox中，不可打印的字符也会触发 keypress 事件，我们要忽略它
        if (e.charCode !== undefined && e.charCode === 0)
            return;
        // Firefox 把打印的字符的ASCII码保存在 charCode 上，而IE保存在 keyCode上
        var code = e.charCode || e.keyCode;
        keyname = String.fromCharCode(code);
        var lowercase = keyname.toLowerCase();
        if (keyname !== lowercase) {
            keyname = lowercase;
            modifiers = 'shift+';
        }
    }
    var func = map[modifiers + keyname];
    if (typeof func === 'function') {
        if (func(e, modifiers + keyname) === false) {
            e.preventDefault();
            e.stopPropagation();
        }
    }
}
function reverse(obj) {
    return Object.keys(obj).reduce(function (all, k) {
        all[obj[k]] = k;
        return all;
    }, {});
}
