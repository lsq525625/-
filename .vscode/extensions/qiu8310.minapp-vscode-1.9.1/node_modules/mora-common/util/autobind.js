"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterateInheritedPrototype_1 = require("./iterateInheritedPrototype");
var getPrototypeOf_1 = require("./getPrototypeOf");
var WONT_BINDS = [
    'constructor',
    'render',
    'componentWillMount',
    'componentDidMount',
    'componentWillReceiveProps',
    'shouldComponentUpdate',
    'componentWillUpdate',
    'componentDidUpdate',
    'componentWillUnmount'
];
function autobind(fromCtor, toCtor, wontBinds) {
    if (toCtor === void 0) { toCtor = null; }
    if (wontBinds === void 0) { wontBinds = WONT_BINDS; }
    if (!fromCtor.prototype && typeof toCtor === 'string' && !Array.isArray(wontBinds))
        return autobindClassMethod(fromCtor, toCtor, wontBinds);
    if (Array.isArray(toCtor)) {
        wontBinds = toCtor;
        toCtor = null;
    }
    if (!toCtor) {
        // 只绑定当前的类，不递归绑定
        _iteraterProperty(fromCtor.prototype, wontBinds);
    }
    else {
        // @FIXED
        // A => B => C，如果在 A 上使用 autoBind，
        // 那么不只有 A 上的函数会 autoBind，
        // B，C 上的函数也都需要 autobind
        iterateInheritedPrototype_1.iterateInheritedPrototype(function (proto) { return _iteraterProperty(proto, wontBinds); }, fromCtor, toCtor, true);
    }
    return fromCtor;
}
exports.autobind = autobind;
function autobindClassMethod(target, method, desc) {
    return bindMethod(getPrototypeOf_1.getPrototypeOf(target), method, desc);
}
function _iteraterProperty(proto, wontBinds) {
    Object.getOwnPropertyNames(proto)
        .filter(function (method) { return wontBinds.indexOf(method) < 0; })
        .forEach(function (method) { return bind(proto, method, Object.getOwnPropertyDescriptor(proto, method)); });
}
function bind(proto, method, desc) {
    if (typeof desc.value !== 'function')
        return; // 此处避免了重复绑定，因为 bind 后都没有 value 值，所以不会出现重复绑定
    Object.defineProperty(proto, method, bindMethod(proto, method, desc));
}
function bindMethod(proto, method, _a) {
    var fn = _a.value, configurable = _a.configurable, enumerable = _a.enumerable;
    return {
        configurable: configurable,
        enumerable: enumerable,
        get: function () {
            // 直接使用原型调用，如 Class.prototype.key
            if (this === proto || this.hasOwnProperty(method))
                return fn;
            // bind 一次就够了，此 bind 会自动根据子类切换 this 环境
            // 如：
            // A1 => B, A2 => B
            // 如果 A1 autobind 之后，B 上函数也会 autobind 到 A1
            // 而在 A2 autobind 之后，B 上函数不需要再 autoBind，但在 A2 上调用 B 上的方法是不会有问题的
            var boundFn = fn.bind(this);
            Object.defineProperty(this, method, {
                value: boundFn,
                configurable: true,
                writable: true
            });
            return boundFn;
        },
        // 为了使子类可以覆写父类的方法
        set: function (value) {
            Object.defineProperty(this, method, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: value
            });
        }
    };
}
