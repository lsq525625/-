"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isObject = require("mora-scripts/libs/lang/isObject");
// 支持处理 {obj: {a: 1, b: 2}, arr: [0, {c: 3}]} => obj.a=1&obj.b=2&arr[0]=1&arr[1].c=3
function buildSearch(query) {
    var search = serialize(query).join('&');
    return (search ? '?' : '') + search;
}
exports.buildSearch = buildSearch;
function serialize(query, scope) {
    if (scope === void 0) { scope = ''; }
    return Object.keys(query).reduce(function (arr, key) {
        var val = query[key];
        var prefix = scope ? scope + ("[" + key + "]") : key;
        // 包括 数组、对象、函数等等
        if (isObject(val)) {
            arr.push.apply(arr, serialize(val, prefix));
        }
        else {
            arr.push(encodeURIComponent(prefix) + '=' + encodeURIComponent(val));
        }
        return arr;
    }, []);
}
function parseSearch(search) {
    search = search[0] === '?' ? search.substr(1) : search;
    return search.length ? unserialize(search) : {};
}
exports.parseSearch = parseSearch;
var PLACEHOLDER_KEY = '__:placeholder:__';
var SCOPE_REG = /(.*?)\[([^\]]*)\]$/;
var NUM_REG = /^\d+$/;
function search2treeNode(search) {
    return search.split('&').reduce(function (nodes, raw) {
        var _a = raw.split('=').map(function (r) { return decodeURIComponent(r); }), key = _a[0], val = _a[1];
        if (!key)
            return nodes;
        var scopes = [];
        while (SCOPE_REG.test(key)) {
            key = RegExp.$1;
            scopes.unshift(RegExp.$2);
        }
        scopes.unshift(key);
        scopes.push(val);
        var parents = nodes;
        var _loop_1 = function (i) {
            var scope = scopes[i] || PLACEHOLDER_KEY;
            var current = parents.filter(function (n) { return n.key === scope && !n.isLeaf; })[0]; // 为什么要限制 !n.isLeaf，如 a=1&a[1]=2 这种结构会导致 a=1 消失
            if (!current) {
                current = { key: scope, numbric: scope === PLACEHOLDER_KEY || NUM_REG.test(scope), isLeaf: i === scopes.length - 1, children: [] };
                parents.push(current);
            }
            parents = current.children;
        };
        for (var i = 0; i < scopes.length; i++) {
            _loop_1(i);
        }
        return nodes;
    }, []);
}
function treeNode2value(node) {
    // Leaf 节点不会有 children 字段
    if (node.isLeaf)
        return node.key;
    // 非 Leaf 节点一定有 children 字段
    var children = node.children;
    var childCount = children.length;
    var firstChild = children[0];
    /**
     * 子节点有多少个叶子节点
     */
    var leafCount = 0;
    /**
     * 子节点有多少个纯数字索引的节点（用于判断是否应该构造数组）
     */
    var numCount = 0;
    var numMap = {}; // 记录已经有的数字
    // @ts-ignore
    var findAvailableNum = function () {
        for (var i = 0; i < childCount; i++) {
            if (!numMap[i]) {
                numMap[i] = true;
                return i;
            }
        }
    };
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        if (child.isLeaf)
            leafCount++;
        else if (child.numbric) {
            numCount++;
            if (child.key !== PLACEHOLDER_KEY)
                numMap[child.key] = true;
        }
    }
    // 将 placeholder 替换成数字
    children.filter(function (child) { return child.key === PLACEHOLDER_KEY; }).forEach(function (child) { return child.key = findAvailableNum() + ''; });
    var isAllNum = numCount === childCount;
    var nodeValue;
    /**
     * 计算 node 节点的权重，方便给第2个条件中的 node 排序
     *
     * a=1&a[0]=3&a[1]=2&a=4 => [1, 4, 3, 2]
     * a[0]=3&a=1&a[1]=2&a=4 => [3, 2, 1, 4]
     */
    var nodeWeight = function (n) { return n.isLeaf ? (firstChild.isLeaf ? -children.indexOf(n) - childCount : children.indexOf(n) + childCount) : (parseInt(n.key, 10) || 0); };
    if (leafCount === childCount) {
        nodeValue = leafCount === 1 ? treeNode2value(firstChild) : children.map(function (child) { return treeNode2value(child); });
    }
    else if (leafCount > 0) {
        if (numCount + leafCount === childCount) {
            nodeValue = children.sort(function (a, b) { return nodeWeight(a) - nodeWeight(b); }).map(function (child) { return child.isLeaf ? child.key : treeNode2value(child); });
        }
        else {
            nodeValue = children.reduce(function (res, child) { child.isLeaf ? res[findAvailableNum()] = child.key : res[child.key] = treeNode2value(child); return res; }, {});
        }
    }
    else {
        if (isAllNum) {
            nodeValue = children.sort(function (a, b) { return parseInt(a.key, 10) - parseInt(b.key, 10); }).map(function (child) { return treeNode2value(child); });
        }
        else {
            nodeValue = children.reduce(function (res, child) { res[child.key] = treeNode2value(child); return res; }, {});
        }
    }
    return nodeValue;
}
function unserialize(search) {
    return search2treeNode(search).reduce(function (query, node) {
        query[node.key] = treeNode2value(node);
        return query;
    }, {});
}
function appendQuery(url, query) {
    if (typeof query === 'object') {
        query = buildSearch(query).slice(1); // 去掉第一个问号
    }
    if (query === '')
        return url;
    var parts = url.split('#');
    return (parts[0] + '&' + query).replace(/[&?]{1,2}/, '?') + (parts.length === 2 ? ('#' + parts[1]) : '');
}
exports.appendQuery = appendQuery;
